"""
Threat Intelligence Correlator Module
State 4: Threat Intelligence Correlation for Malware Agent
Correlates indicators with threat intelligence feeds, campaigns, and threat actor tools
"""

import logging
import asyncio
import aiohttp
import json
from typing import Dict, Any, List, Optional, Set, Tuple
from datetime import datetime, timedelta
import hashlib
import re

logger = logging.getLogger(__name__)

class ThreatIntelligenceCorrelator:
    """
    Threat Intelligence Correlation for malware analysis
    Correlates findings with threat intelligence feeds and campaign data
    """
    
    def __init__(self):
        self.mitre_attack_db = self._load_mitre_attack_db()
        self.threat_actor_db = self._load_threat_actor_db()
        self.campaign_signatures = self._load_campaign_signatures()
        self.yara_rules = self._load_yara_rules()
        
    async def correlate_threat_intelligence(self, malware_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """
        Correlate malware analysis with threat intelligence
        
        Args:
            malware_analysis: Combined results from previous analysis states
            
        Returns:
            Threat intelligence correlation results
        """
        logger.info("Starting threat intelligence correlation")
        
        correlation_results = {
            "campaign_matches": [],
            "threat_actor_attribution": {},
            "mitre_techniques": [],
            "tool_identification": {},
            "similar_samples": [],
            "intelligence_feeds": {},
            "confidence_scores": {},
            "correlation_timestamp": datetime.now()
        }
        
        try:
            # Extract indicators from analysis
            indicators = await self._extract_indicators(malware_analysis)
            
            # Campaign correlation
            campaign_matches = await self._correlate_campaigns(indicators, malware_analysis)
            correlation_results["campaign_matches"] = campaign_matches
            
            # Threat actor attribution
            actor_attribution = await self._attribute_threat_actors(indicators, malware_analysis)
            correlation_results["threat_actor_attribution"] = actor_attribution
            
            # MITRE ATT&CK mapping
            mitre_techniques = await self._map_mitre_techniques(malware_analysis)
            correlation_results["mitre_techniques"] = mitre_techniques
            
            # Tool identification
            tool_identification = await self._identify_tools(indicators, malware_analysis)
            correlation_results["tool_identification"] = tool_identification
            
            # Similar sample analysis
            similar_samples = await self._find_similar_samples(indicators)
            correlation_results["similar_samples"] = similar_samples
            
            # Intelligence feed correlation
            feed_results = await self._correlate_intelligence_feeds(indicators)
            correlation_results["intelligence_feeds"] = feed_results
            
            # Calculate confidence scores
            confidence_scores = await self._calculate_confidence_scores(correlation_results)
            correlation_results["confidence_scores"] = confidence_scores
            
            logger.info("Threat intelligence correlation completed")
            
        except Exception as e:
            logger.error(f"Error in threat intelligence correlation: {str(e)}")
            correlation_results["error"] = str(e)
            
        return correlation_results
    
    async def _extract_indicators(self, malware_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Extract indicators of compromise from malware analysis"""
        indicators = {
            "file_hashes": set(),
            "domains": set(),
            "ips": set(),
            "urls": set(),
            "registry_keys": set(),
            "file_paths": set(),
            "mutex_names": set(),
            "service_names": set(),
            "process_names": set(),
            "behaviors": set()
        }
        
        # Extract from file analysis
        file_analysis = malware_analysis.get("file_hash_analysis", {})
        hash_data = file_analysis.get("hash_analysis", {}).get("hashes", {})
        for hash_type, hash_value in hash_data.items():
            indicators["file_hashes"].add(f"{hash_type}:{hash_value}")
        
        # Extract from behavioral analysis
        behavioral_analysis = malware_analysis.get("behavioral_analysis", {})
        
        # Network indicators
        network_comms = behavioral_analysis.get("network_communications", {})
        for domain in network_comms.get("suspicious_domains", []):
            indicators["domains"].add(domain.get("domain", ""))
        
        for connection in network_comms.get("outbound_connections", []):
            if "destination_ip" in connection:
                indicators["ips"].add(connection["destination_ip"])
        
        # Registry indicators
        registry_changes = behavioral_analysis.get("registry_changes", {})
        for key_info in registry_changes.get("persistence_keys", []):
            indicators["registry_keys"].add(key_info.get("key_path", ""))
        
        # File system indicators
        fs_activities = behavioral_analysis.get("file_system_activities", {})
        for file_creation in fs_activities.get("file_creations", []):
            indicators["file_paths"].add(file_creation.get("file_path", ""))
        
        # Process indicators
        process_behavior = behavioral_analysis.get("process_behavior", {})
        for process in process_behavior.get("suspicious_processes", []):
            indicators["process_names"].add(process.get("process_name", ""))
        
        # C2 indicators
        c2_detection = malware_analysis.get("c2_detection", {})
        for domain_info in c2_detection.get("c2_domains", []):
            indicators["domains"].add(domain_info.get("domain", ""))
        
        for ip_info in c2_detection.get("c2_ips", []):
            indicators["ips"].add(ip_info.get("ip", ""))
        
        # Convert sets to lists for JSON serialization
        return {k: list(v) for k, v in indicators.items()}
    
    async def _correlate_campaigns(self, indicators: Dict[str, Any], analysis: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Correlate with known malware campaigns"""
        campaign_matches = []
        
        for campaign_name, campaign_data in self.campaign_signatures.items():
            match_score = await self._calculate_campaign_match_score(
                indicators, analysis, campaign_data
            )
            
            if match_score > 0.3:  # Threshold for campaign match
                campaign_match = {
                    "campaign_name": campaign_name,
                    "match_score": match_score,
                    "matched_indicators": await self._get_matched_indicators(indicators, campaign_data),
                    "campaign_description": campaign_data.get("description", ""),
                    "first_seen": campaign_data.get("first_seen", ""),
                    "last_seen": campaign_data.get("last_seen", ""),
                    "associated_groups": campaign_data.get("threat_groups", []),
                    "target_sectors": campaign_data.get("target_sectors", [])
                }
                campaign_matches.append(campaign_match)
        
        # Sort by match score
        campaign_matches.sort(key=lambda x: x["match_score"], reverse=True)
        
        return campaign_matches[:10]  # Return top 10 matches
    
    async def _attribute_threat_actors(self, indicators: Dict[str, Any], analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Attribute malware to threat actors"""
        attribution = {
            "primary_attribution": {},
            "possible_attributions": [],
            "attribution_confidence": 0.0,
            "attribution_factors": []
        }
        
        actor_scores = {}
        
        for actor_name, actor_data in self.threat_actor_db.items():
            score = await self._calculate_actor_attribution_score(
                indicators, analysis, actor_data
            )
            
            if score > 0.2:  # Threshold for possible attribution
                actor_scores[actor_name] = {
                    "score": score,
                    "actor_data": actor_data,
                    "matched_techniques": await self._get_matched_techniques(analysis, actor_data),
                    "matched_tools": await self._get_matched_tools(indicators, actor_data)
                }
        
        # Sort actors by score
        sorted_actors = sorted(actor_scores.items(), key=lambda x: x[1]["score"], reverse=True)
        
        if sorted_actors:
            # Primary attribution (highest score)
            primary_actor = sorted_actors[0]
            attribution["primary_attribution"] = {
                "actor_name": primary_actor[0],
                "confidence": primary_actor[1]["score"],
                "description": primary_actor[1]["actor_data"].get("description", ""),
                "country": primary_actor[1]["actor_data"].get("country", "Unknown"),
                "motivation": primary_actor[1]["actor_data"].get("motivation", []),
                "matched_techniques": primary_actor[1]["matched_techniques"],
                "matched_tools": primary_actor[1]["matched_tools"]
            }
            
            # Possible attributions
            attribution["possible_attributions"] = [
                {
                    "actor_name": actor[0],
                    "confidence": actor[1]["score"],
                    "description": actor[1]["actor_data"].get("description", "")
                }
                for actor in sorted_actors[1:6]  # Top 5 additional possibilities
            ]
            
            attribution["attribution_confidence"] = primary_actor[1]["score"]
        
        return attribution
    
    async def _map_mitre_techniques(self, analysis: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Map observed behaviors to MITRE ATT&CK techniques"""
        mitre_techniques = []
        
        # Analyze behaviors and map to techniques
        behavioral_analysis = analysis.get("behavioral_analysis", {})
        
        # Process behavior mapping
        process_behavior = behavioral_analysis.get("process_behavior", {})
        if process_behavior.get("process_injection"):
            mitre_techniques.append({
                "technique_id": "T1055",
                "technique_name": "Process Injection",
                "tactic": "Defense Evasion",
                "confidence": 0.8,
                "evidence": "Process injection detected in behavioral analysis"
            })
        
        if process_behavior.get("hollowing_indicators"):
            mitre_techniques.append({
                "technique_id": "T1055.012",
                "technique_name": "Process Hollowing",
                "tactic": "Defense Evasion",
                "confidence": 0.7,
                "evidence": "Process hollowing indicators detected"
            })
        
        # Persistence mechanism mapping
        persistence = behavioral_analysis.get("persistence_mechanisms", {})
        if persistence.get("registry_persistence"):
            mitre_techniques.append({
                "technique_id": "T1547.001",
                "technique_name": "Registry Run Keys / Startup Folder",
                "tactic": "Persistence",
                "confidence": 0.9,
                "evidence": "Registry persistence mechanisms detected"
            })
        
        if persistence.get("service_persistence"):
            mitre_techniques.append({
                "technique_id": "T1543.003",
                "technique_name": "Windows Service",
                "tactic": "Persistence",
                "confidence": 0.8,
                "evidence": "Service persistence detected"
            })
        
        # Network communication mapping
        c2_detection = analysis.get("c2_detection", {})
        if c2_detection.get("beacon_analysis", {}).get("periodic_beacons"):
            mitre_techniques.append({
                "technique_id": "T1071",
                "technique_name": "Application Layer Protocol",
                "tactic": "Command and Control",
                "confidence": 0.7,
                "evidence": "Periodic beacon communication detected"
            })
        
        # Data exfiltration mapping
        if c2_detection.get("traffic_patterns", {}).get("data_exfiltration"):
            mitre_techniques.append({
                "technique_id": "T1041",
                "technique_name": "Exfiltration Over C2 Channel",
                "tactic": "Exfiltration",
                "confidence": 0.6,
                "evidence": "Data exfiltration patterns detected"
            })
        
        return mitre_techniques
    
    async def _identify_tools(self, indicators: Dict[str, Any], analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Identify malware tools and frameworks"""
        tool_identification = {
            "identified_tools": [],
            "framework_matches": [],
            "packer_detection": {},
            "crypter_detection": {}
        }
        
        # Check for known tool signatures
        file_analysis = analysis.get("file_hash_analysis", {})
        pe_analysis = file_analysis.get("pe_analysis", {})
        
        # Analyze imports for tool signatures
        imports = pe_analysis.get("imports", [])
        tool_identification["identified_tools"] = await self._analyze_tool_imports(imports)
        
        # Check for framework signatures
        behavioral_analysis = analysis.get("behavioral_analysis", {})
        tool_identification["framework_matches"] = await self._check_framework_signatures(behavioral_analysis)
        
        # Packer detection
        tool_identification["packer_detection"] = await self._detect_packers(pe_analysis)
        
        # Crypter detection
        tool_identification["crypter_detection"] = await self._detect_crypters(analysis)
        
        return tool_identification
    
    async def _find_similar_samples(self, indicators: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find similar malware samples"""
        similar_samples = []
        
        # This would typically query a malware database
        # For now, we'll simulate the response
        
        file_hashes = indicators.get("file_hashes", [])
        domains = indicators.get("domains", [])
        
        if file_hashes or domains:
            # Simulate database query results
            similar_samples = [
                {
                    "sample_hash": "abc123...",
                    "similarity_score": 0.85,
                    "first_seen": "2024-01-15",
                    "family": "TrickBot",
                    "shared_indicators": ["domain:malicious-domain.com", "registry:HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"]
                },
                {
                    "sample_hash": "def456...",
                    "similarity_score": 0.72,
                    "first_seen": "2024-01-20",
                    "family": "Emotet",
                    "shared_indicators": ["mutex:Global\\emotet_mutex"]
                }
            ]
        
        return similar_samples
    
    async def _correlate_intelligence_feeds(self, indicators: Dict[str, Any]) -> Dict[str, Any]:
        """Correlate with external intelligence feeds"""
        feed_results = {
            "abuse_ch": {},
            "malware_bazaar": {},
            "threat_fox": {},
            "feodo_tracker": {},
            "custom_feeds": []
        }
        
        # Correlate with abuse.ch feeds
        feed_results["abuse_ch"] = await self._correlate_abuse_ch(indicators)
        
        # Correlate with MalwareBazaar
        feed_results["malware_bazaar"] = await self._correlate_malware_bazaar(indicators)
        
        # Correlate with ThreatFox
        feed_results["threat_fox"] = await self._correlate_threat_fox(indicators)
        
        # Correlate with Feodo Tracker
        feed_results["feodo_tracker"] = await self._correlate_feodo_tracker(indicators)
        
        return feed_results
    
    async def _calculate_confidence_scores(self, correlation_results: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate confidence scores for correlations"""
        confidence_scores = {
            "overall_confidence": 0.0,
            "campaign_confidence": 0.0,
            "attribution_confidence": 0.0,
            "technique_confidence": 0.0
        }
        
        # Campaign confidence
        campaigns = correlation_results.get("campaign_matches", [])
        if campaigns:
            confidence_scores["campaign_confidence"] = max(c.get("match_score", 0) for c in campaigns)
        
        # Attribution confidence
        attribution = correlation_results.get("threat_actor_attribution", {})
        confidence_scores["attribution_confidence"] = attribution.get("attribution_confidence", 0.0)
        
        # Technique confidence
        techniques = correlation_results.get("mitre_techniques", [])
        if techniques:
            confidence_scores["technique_confidence"] = sum(t.get("confidence", 0) for t in techniques) / len(techniques)
        
        # Overall confidence
        confidence_scores["overall_confidence"] = (
            confidence_scores["campaign_confidence"] * 0.3 +
            confidence_scores["attribution_confidence"] * 0.4 +
            confidence_scores["technique_confidence"] * 0.3
        )
        
        return confidence_scores
    
    # Helper methods
    async def _calculate_campaign_match_score(self, indicators: Dict[str, Any], 
                                            analysis: Dict[str, Any], 
                                            campaign_data: Dict[str, Any]) -> float:
        """Calculate match score for a campaign"""
        score = 0.0
        total_possible = 0
        
        # Check indicator matches
        campaign_indicators = campaign_data.get("indicators", {})
        
        for indicator_type, indicator_list in indicators.items():
            if indicator_type in campaign_indicators:
                campaign_set = set(campaign_indicators[indicator_type])
                indicator_set = set(indicator_list)
                matches = len(campaign_set.intersection(indicator_set))
                total_indicators = len(campaign_set) + len(indicator_set)
                
                if total_indicators > 0:
                    score += (matches * 2) / total_indicators
                    total_possible += 1
        
        # Check technique matches
        campaign_techniques = set(campaign_data.get("mitre_techniques", []))
        analysis_techniques = set()
        
        mitre_techniques = analysis.get("mitre_techniques", [])
        for technique in mitre_techniques:
            analysis_techniques.add(technique.get("technique_id", ""))
        
        if campaign_techniques and analysis_techniques:
            technique_matches = len(campaign_techniques.intersection(analysis_techniques))
            technique_score = technique_matches / len(campaign_techniques)
            score += technique_score
            total_possible += 1
        
        return score / max(total_possible, 1)
    
    def _load_mitre_attack_db(self) -> Dict[str, Any]:
        """Load MITRE ATT&CK database"""
        return {
            "T1055": {
                "name": "Process Injection",
                "tactics": ["Defense Evasion", "Privilege Escalation"],
                "description": "Adversaries may inject code into processes..."
            },
            "T1547.001": {
                "name": "Registry Run Keys / Startup Folder",
                "tactics": ["Persistence", "Privilege Escalation"],
                "description": "Adversaries may achieve persistence..."
            }
        }
    
    def _load_threat_actor_db(self) -> Dict[str, Any]:
        """Load threat actor database"""
        return {
            "APT1": {
                "description": "Chinese cyber espionage group",
                "country": "China",
                "motivation": ["espionage"],
                "techniques": ["T1055", "T1547.001"],
                "tools": ["Poison Ivy", "Backdoor.APT1"]
            },
            "Lazarus Group": {
                "description": "North Korean state-sponsored group",
                "country": "North Korea",
                "motivation": ["financial", "espionage"],
                "techniques": ["T1055", "T1071"],
                "tools": ["Destover", "WannaCry"]
            }
        }
    
    def _load_campaign_signatures(self) -> Dict[str, Any]:
        """Load campaign signature database"""
        return {
            "Operation Aurora": {
                "description": "Advanced persistent threat campaign",
                "first_seen": "2009-12-01",
                "last_seen": "2010-01-31",
                "threat_groups": ["APT1"],
                "target_sectors": ["Technology", "Finance"],
                "indicators": {
                    "domains": ["malicious-domain.com"],
                    "file_hashes": ["md5:abc123def456"]
                },
                "mitre_techniques": ["T1055", "T1071"]
            }
        }
    
    def _load_yara_rules(self) -> Dict[str, str]:
        """Load YARA rules for malware detection"""
        return {
            "emotet": """
                rule Emotet {
                    meta:
                        description = "Emotet Malware"
                    strings:
                        $s1 = "emotet" nocase
                        $s2 = { 6A 40 68 00 30 00 00 }
                    condition:
                        any of them
                }
            """
        }

# Factory function
def create_threat_intelligence_correlator() -> ThreatIntelligenceCorrelator:
    """Create and return ThreatIntelligenceCorrelator instance"""
    return ThreatIntelligenceCorrelator()
