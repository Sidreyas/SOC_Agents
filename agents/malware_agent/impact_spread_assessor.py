"""
Impact and Spread Assessment Module
State 5: Impact Assessment for Malware Agent
Evaluates malware impact, lateral spread, and containment effectiveness
"""

import logging
import asyncio
from typing import Dict, Any, List, Optional, Set, Tuple
from datetime import datetime, timedelta
import json
from enum import Enum

logger = logging.getLogger(__name__)

class ImpactSeverity(Enum):
    """Impact severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class SpreadStatus(Enum):
    """Malware spread status"""
    CONTAINED = "contained"
    LIMITED_SPREAD = "limited_spread"
    ACTIVE_SPREAD = "active_spread"
    WIDESPREAD = "widespread"

class ImpactSpreadAssessor:
    """
    Impact and Spread Assessment for malware analysis
    Evaluates organizational impact and malware propagation
    """
    
    def __init__(self):
        self.business_systems = self._load_business_systems()
        self.network_topology = self._load_network_topology()
        self.containment_measures = self._load_containment_measures()
        
    async def assess_impact_and_spread(self, malware_data: Dict[str, Any], 
                                     sentinel_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Assess malware impact and spread across the organization
        
        Args:
            malware_data: Combined malware analysis results
            sentinel_data: Microsoft Sentinel correlation data
            
        Returns:
            Impact and spread assessment results
        """
        logger.info("Starting impact and spread assessment")
        
        assessment_results = {
            "impact_assessment": {},
            "spread_analysis": {},
            "affected_systems": [],
            "lateral_movement": {},
            "data_compromise": {},
            "business_impact": {},
            "containment_status": {},
            "risk_scoring": {},
            "assessment_timestamp": datetime.now()
        }
        
        try:
            # Impact assessment
            impact_results = await self._assess_organizational_impact(malware_data, sentinel_data)
            assessment_results["impact_assessment"] = impact_results
            
            # Spread analysis
            spread_results = await self._analyze_malware_spread(malware_data, sentinel_data)
            assessment_results["spread_analysis"] = spread_results
            
            # Affected systems identification
            affected_systems = await self._identify_affected_systems(sentinel_data)
            assessment_results["affected_systems"] = affected_systems
            
            # Lateral movement analysis
            lateral_movement = await self._analyze_lateral_movement(malware_data, sentinel_data)
            assessment_results["lateral_movement"] = lateral_movement
            
            # Data compromise assessment
            data_compromise = await self._assess_data_compromise(malware_data, affected_systems)
            assessment_results["data_compromise"] = data_compromise
            
            # Business impact analysis
            business_impact = await self._analyze_business_impact(affected_systems, impact_results)
            assessment_results["business_impact"] = business_impact
            
            # Containment status
            containment_status = await self._assess_containment_effectiveness(malware_data, sentinel_data)
            assessment_results["containment_status"] = containment_status
            
            # Risk scoring
            risk_scoring = await self._calculate_risk_scores(assessment_results)
            assessment_results["risk_scoring"] = risk_scoring
            
            logger.info("Impact and spread assessment completed")
            
        except Exception as e:
            logger.error(f"Error in impact and spread assessment: {str(e)}")
            assessment_results["error"] = str(e)
            
        return assessment_results
    
    async def _assess_organizational_impact(self, malware_data: Dict[str, Any], 
                                          sentinel_data: Dict[str, Any]) -> Dict[str, Any]:
        """Assess impact on organizational operations"""
        impact_assessment = {
            "severity_level": ImpactSeverity.LOW.value,
            "affected_business_units": [],
            "critical_system_impact": {},
            "service_disruption": {},
            "compliance_implications": {},
            "reputation_risk": {}
        }
        
        # Analyze affected systems
        affected_systems = await self._get_affected_systems_from_sentinel(sentinel_data)
        
        # Determine severity level
        severity = await self._calculate_impact_severity(affected_systems, malware_data)
        impact_assessment["severity_level"] = severity
        
        # Identify affected business units
        business_units = await self._map_systems_to_business_units(affected_systems)
        impact_assessment["affected_business_units"] = business_units
        
        # Critical system impact
        critical_impact = await self._assess_critical_system_impact(affected_systems)
        impact_assessment["critical_system_impact"] = critical_impact
        
        # Service disruption analysis
        service_disruption = await self._analyze_service_disruption(affected_systems)
        impact_assessment["service_disruption"] = service_disruption
        
        # Compliance implications
        compliance_implications = await self._assess_compliance_implications(malware_data, affected_systems)
        impact_assessment["compliance_implications"] = compliance_implications
        
        # Reputation risk
        reputation_risk = await self._assess_reputation_risk(impact_assessment)
        impact_assessment["reputation_risk"] = reputation_risk
        
        return impact_assessment
    
    async def _analyze_malware_spread(self, malware_data: Dict[str, Any], 
                                    sentinel_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze malware spread patterns"""
        spread_analysis = {
            "spread_status": SpreadStatus.CONTAINED.value,
            "infection_timeline": [],
            "spread_vectors": [],
            "propagation_methods": [],
            "network_segments_affected": [],
            "spread_velocity": 0.0,
            "containment_barriers": []
        }
        
        # Analyze infection timeline
        timeline = await self._build_infection_timeline(sentinel_data)
        spread_analysis["infection_timeline"] = timeline
        
        # Identify spread vectors
        vectors = await self._identify_spread_vectors(malware_data, sentinel_data)
        spread_analysis["spread_vectors"] = vectors
        
        # Analyze propagation methods
        propagation = await self._analyze_propagation_methods(malware_data)
        spread_analysis["propagation_methods"] = propagation
        
        # Network segment analysis
        segments = await self._analyze_affected_network_segments(sentinel_data)
        spread_analysis["network_segments_affected"] = segments
        
        # Calculate spread velocity
        velocity = await self._calculate_spread_velocity(timeline)
        spread_analysis["spread_velocity"] = velocity
        
        # Assess containment barriers
        barriers = await self._assess_containment_barriers(segments, vectors)
        spread_analysis["containment_barriers"] = barriers
        
        # Determine overall spread status
        spread_status = await self._determine_spread_status(spread_analysis)
        spread_analysis["spread_status"] = spread_status
        
        return spread_analysis
    
    async def _identify_affected_systems(self, sentinel_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Identify all systems affected by malware"""
        affected_systems = []
        
        # Extract from Sentinel alerts
        alerts = sentinel_data.get("alerts", [])
        for alert in alerts:
            entities = alert.get("entities", [])
            for entity in entities:
                if entity.get("type") == "host":
                    system_info = {
                        "hostname": entity.get("hostName"),
                        "ip_address": entity.get("address"),
                        "domain": entity.get("dnsDomain"),
                        "os_family": entity.get("oSFamily"),
                        "os_version": entity.get("oSVersion"),
                        "first_seen": alert.get("timeGenerated"),
                        "alert_severity": alert.get("severity"),
                        "compromise_indicators": []
                    }
                    
                    # Add compromise indicators
                    system_info["compromise_indicators"] = await self._extract_compromise_indicators(alert, entity)
                    
                    affected_systems.append(system_info)
        
        # Remove duplicates and merge information
        unique_systems = await self._merge_duplicate_systems(affected_systems)
        
        return unique_systems
    
    async def _analyze_lateral_movement(self, malware_data: Dict[str, Any], 
                                      sentinel_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze lateral movement patterns"""
        lateral_movement = {
            "movement_detected": False,
            "movement_techniques": [],
            "credential_reuse": [],
            "privilege_escalation": [],
            "network_reconnaissance": [],
            "movement_timeline": [],
            "affected_credentials": []
        }
        
        # Check for lateral movement indicators
        behavioral_analysis = malware_data.get("behavioral_analysis", {})
        
        # Analyze authentication patterns
        auth_events = await self._extract_authentication_events(sentinel_data)
        lateral_movement["credential_reuse"] = await self._detect_credential_reuse(auth_events)
        
        # Privilege escalation detection
        privilege_events = behavioral_analysis.get("privilege_escalation", {})
        lateral_movement["privilege_escalation"] = await self._analyze_privilege_escalation_spread(privilege_events)
        
        # Network reconnaissance
        network_events = behavioral_analysis.get("network_communications", {})
        lateral_movement["network_reconnaissance"] = await self._detect_reconnaissance_activities(network_events)
        
        # Movement techniques
        lateral_movement["movement_techniques"] = await self._identify_movement_techniques(malware_data)
        
        # Movement timeline
        lateral_movement["movement_timeline"] = await self._build_movement_timeline(auth_events, privilege_events)
        
        # Affected credentials
        lateral_movement["affected_credentials"] = await self._identify_affected_credentials(auth_events)
        
        # Set detection flag
        lateral_movement["movement_detected"] = (
            len(lateral_movement["credential_reuse"]) > 0 or
            len(lateral_movement["privilege_escalation"]) > 0 or
            len(lateral_movement["movement_techniques"]) > 0
        )
        
        return lateral_movement
    
    async def _assess_data_compromise(self, malware_data: Dict[str, Any], 
                                    affected_systems: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess potential data compromise"""
        data_compromise = {
            "compromise_likelihood": 0.0,
            "sensitive_data_access": [],
            "exfiltration_indicators": [],
            "encryption_activities": [],
            "database_access": [],
            "file_system_compromise": {},
            "data_classification_impact": {}
        }
        
        # Analyze data access patterns
        behavioral_analysis = malware_data.get("behavioral_analysis", {})
        fs_activities = behavioral_analysis.get("file_system_activities", {})
        
        # Check for sensitive data access
        data_compromise["sensitive_data_access"] = await self._detect_sensitive_data_access(fs_activities, affected_systems)
        
        # Exfiltration indicators
        c2_detection = malware_data.get("c2_detection", {})
        traffic_patterns = c2_detection.get("traffic_patterns", {})
        data_compromise["exfiltration_indicators"] = traffic_patterns.get("data_exfiltration", [])
        
        # Encryption activities (potential ransomware)
        data_compromise["encryption_activities"] = fs_activities.get("encryption_activities", [])
        
        # Database access analysis
        data_compromise["database_access"] = await self._analyze_database_access(affected_systems)
        
        # File system compromise
        data_compromise["file_system_compromise"] = await self._assess_file_system_compromise(fs_activities)
        
        # Data classification impact
        data_compromise["data_classification_impact"] = await self._assess_data_classification_impact(
            data_compromise["sensitive_data_access"]
        )
        
        # Calculate compromise likelihood
        data_compromise["compromise_likelihood"] = await self._calculate_compromise_likelihood(data_compromise)
        
        return data_compromise
    
    async def _analyze_business_impact(self, affected_systems: List[Dict[str, Any]], 
                                     impact_assessment: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze business impact"""
        business_impact = {
            "financial_impact": {},
            "operational_impact": {},
            "regulatory_impact": {},
            "customer_impact": {},
            "supply_chain_impact": {},
            "recovery_estimate": {}
        }
        
        # Financial impact assessment
        business_impact["financial_impact"] = await self._assess_financial_impact(affected_systems, impact_assessment)
        
        # Operational impact
        business_impact["operational_impact"] = await self._assess_operational_impact(affected_systems)
        
        # Regulatory impact
        business_impact["regulatory_impact"] = impact_assessment.get("compliance_implications", {})
        
        # Customer impact
        business_impact["customer_impact"] = await self._assess_customer_impact(affected_systems)
        
        # Supply chain impact
        business_impact["supply_chain_impact"] = await self._assess_supply_chain_impact(affected_systems)
        
        # Recovery estimate
        business_impact["recovery_estimate"] = await self._estimate_recovery_time(business_impact)
        
        return business_impact
    
    async def _assess_containment_effectiveness(self, malware_data: Dict[str, Any], 
                                              sentinel_data: Dict[str, Any]) -> Dict[str, Any]:
        """Assess containment effectiveness"""
        containment_status = {
            "containment_measures": [],
            "effectiveness_score": 0.0,
            "bypass_attempts": [],
            "remaining_threats": [],
            "isolation_status": {},
            "eradication_progress": {}
        }
        
        # Identify active containment measures
        containment_status["containment_measures"] = await self._identify_containment_measures(sentinel_data)
        
        # Assess bypass attempts
        containment_status["bypass_attempts"] = await self._detect_containment_bypass(malware_data)
        
        # Identify remaining threats
        containment_status["remaining_threats"] = await self._identify_remaining_threats(malware_data, sentinel_data)
        
        # System isolation status
        containment_status["isolation_status"] = await self._assess_isolation_status(sentinel_data)
        
        # Eradication progress
        containment_status["eradication_progress"] = await self._assess_eradication_progress(sentinel_data)
        
        # Calculate effectiveness score
        containment_status["effectiveness_score"] = await self._calculate_containment_effectiveness(containment_status)
        
        return containment_status
    
    async def _calculate_risk_scores(self, assessment_results: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate comprehensive risk scores"""
        risk_scoring = {
            "overall_risk_score": 0.0,
            "impact_score": 0.0,
            "spread_risk_score": 0.0,
            "containment_risk_score": 0.0,
            "business_risk_score": 0.0,
            "data_risk_score": 0.0,
            "risk_factors": []
        }
        
        # Impact score
        impact_assessment = assessment_results.get("impact_assessment", {})
        severity = impact_assessment.get("severity_level", "low")
        risk_scoring["impact_score"] = self._severity_to_score(severity)
        
        # Spread risk score
        spread_analysis = assessment_results.get("spread_analysis", {})
        spread_status = spread_analysis.get("spread_status", "contained")
        spread_velocity = spread_analysis.get("spread_velocity", 0.0)
        risk_scoring["spread_risk_score"] = self._calculate_spread_risk(spread_status, spread_velocity)
        
        # Containment risk score
        containment_status = assessment_results.get("containment_status", {})
        effectiveness = containment_status.get("effectiveness_score", 1.0)
        risk_scoring["containment_risk_score"] = 1.0 - effectiveness
        
        # Business risk score
        business_impact = assessment_results.get("business_impact", {})
        risk_scoring["business_risk_score"] = await self._calculate_business_risk_score(business_impact)
        
        # Data risk score
        data_compromise = assessment_results.get("data_compromise", {})
        compromise_likelihood = data_compromise.get("compromise_likelihood", 0.0)
        risk_scoring["data_risk_score"] = compromise_likelihood
        
        # Overall risk score (weighted average)
        risk_scoring["overall_risk_score"] = (
            risk_scoring["impact_score"] * 0.25 +
            risk_scoring["spread_risk_score"] * 0.20 +
            risk_scoring["containment_risk_score"] * 0.15 +
            risk_scoring["business_risk_score"] * 0.25 +
            risk_scoring["data_risk_score"] * 0.15
        )
        
        # Risk factors
        risk_scoring["risk_factors"] = await self._identify_risk_factors(assessment_results)
        
        return risk_scoring
    
    # Helper methods
    def _severity_to_score(self, severity: str) -> float:
        """Convert severity level to numeric score"""
        severity_scores = {
            "low": 0.25,
            "medium": 0.50,
            "high": 0.75,
            "critical": 1.0
        }
        return severity_scores.get(severity.lower(), 0.25)
    
    def _calculate_spread_risk(self, spread_status: str, velocity: float) -> float:
        """Calculate spread risk score"""
        status_scores = {
            "contained": 0.2,
            "limited_spread": 0.4,
            "active_spread": 0.7,
            "widespread": 1.0
        }
        
        base_score = status_scores.get(spread_status.lower(), 0.2)
        velocity_factor = min(velocity / 10.0, 0.3)  # Cap velocity impact
        
        return min(base_score + velocity_factor, 1.0)
    
    def _load_business_systems(self) -> Dict[str, Any]:
        """Load business system classifications"""
        return {
            "critical_systems": ["domain_controllers", "email_servers", "database_servers"],
            "business_applications": ["erp", "crm", "hr_systems"],
            "infrastructure": ["dns_servers", "dhcp_servers", "file_servers"]
        }
    
    def _load_network_topology(self) -> Dict[str, Any]:
        """Load network topology information"""
        return {
            "segments": ["dmz", "internal", "management", "guest"],
            "trust_relationships": {},
            "isolation_capabilities": {}
        }
    
    def _load_containment_measures(self) -> List[str]:
        """Load available containment measures"""
        return [
            "network_isolation",
            "process_termination", 
            "file_quarantine",
            "account_disable",
            "system_shutdown"
        ]

# Factory function
def create_impact_spread_assessor() -> ImpactSpreadAssessor:
    """Create and return ImpactSpreadAssessor instance"""
    return ImpactSpreadAssessor()
