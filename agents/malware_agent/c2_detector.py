"""
Command and Control Detection Module
State 3: C2 Detection for Malware Agent
Analyzes network indicators for C2 infrastructure using URLhaus, VirusTotal, and correlation analysis
"""

import logging
import asyncio
import aiohttp
import re
import hashlib
from typing import Dict, Any, List, Optional, Set, Tuple
from datetime import datetime, timedelta
import json
import ipaddress
from urllib.parse import urlparse, parse_qs
import dns.resolver

logger = logging.getLogger(__name__)

class C2Detector:
    """
    Command and Control Detection for malware analysis
    Detects C2 infrastructure, beacons, and communication patterns
    """
    
    def __init__(self):
        self.urlhaus_api = "https://urlhaus-api.abuse.ch/v1/"
        self.virustotal_api = "https://www.virustotal.com/vtapi/v2/"
        self.c2_patterns = self._load_c2_patterns()
        self.beacon_analysis = self._load_beacon_patterns()
        
    async def detect_c2_infrastructure(self, network_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Detect command and control infrastructure
        
        Args:
            network_data: Network communication data from behavioral analysis
            
        Returns:
            C2 detection results and analysis
        """
        logger.info("Starting C2 infrastructure detection")
        
        detection_results = {
            "c2_domains": [],
            "c2_ips": [],
            "beacon_analysis": {},
            "urlhaus_results": {},
            "virustotal_results": {},
            "dns_analysis": {},
            "traffic_patterns": {},
            "c2_confidence_score": 0.0,
            "detection_timestamp": datetime.now()
        }
        
        try:
            # Extract network indicators
            network_indicators = await self._extract_network_indicators(network_data)
            
            # Analyze domains for C2 characteristics
            domain_results = await self._analyze_c2_domains(network_indicators.get("domains", []))
            detection_results["c2_domains"] = domain_results
            
            # Analyze IP addresses for C2 characteristics
            ip_results = await self._analyze_c2_ips(network_indicators.get("ips", []))
            detection_results["c2_ips"] = ip_results
            
            # Beacon analysis
            beacon_results = await self._analyze_beacon_patterns(network_data)
            detection_results["beacon_analysis"] = beacon_results
            
            # URLhaus analysis
            urlhaus_results = await self._query_urlhaus(network_indicators)
            detection_results["urlhaus_results"] = urlhaus_results
            
            # VirusTotal analysis
            vt_results = await self._query_virustotal(network_indicators)
            detection_results["virustotal_results"] = vt_results
            
            # DNS analysis
            dns_results = await self._analyze_dns_patterns(network_data)
            detection_results["dns_analysis"] = dns_results
            
            # Traffic pattern analysis
            traffic_results = await self._analyze_traffic_patterns(network_data)
            detection_results["traffic_patterns"] = traffic_results
            
            # Calculate C2 confidence score
            confidence_score = await self._calculate_c2_confidence(detection_results)
            detection_results["c2_confidence_score"] = confidence_score
            
            logger.info(f"C2 detection completed with confidence: {confidence_score}")
            
        except Exception as e:
            logger.error(f"Error in C2 detection: {str(e)}")
            detection_results["error"] = str(e)
            
        return detection_results
    
    async def _extract_network_indicators(self, network_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract network indicators from communication data"""
        indicators = {
            "domains": set(),
            "ips": set(),
            "urls": set(),
            "user_agents": set(),
            "ports": set(),
            "protocols": set()
        }
        
        # Extract from outbound connections
        connections = network_data.get("outbound_connections", [])
        for conn in connections:
            if "destination_ip" in conn:
                indicators["ips"].add(conn["destination_ip"])
            if "destination_port" in conn:
                indicators["ports"].add(conn["destination_port"])
            if "protocol" in conn:
                indicators["protocols"].add(conn["protocol"])
        
        # Extract from DNS queries
        dns_queries = network_data.get("dns_queries", [])
        for query in dns_queries:
            if "domain" in query:
                indicators["domains"].add(query["domain"])
        
        # Extract from HTTP requests
        http_requests = network_data.get("http_requests", [])
        for request in http_requests:
            if "url" in request:
                indicators["urls"].add(request["url"])
                # Extract domain from URL
                parsed_url = urlparse(request["url"])
                if parsed_url.netloc:
                    indicators["domains"].add(parsed_url.netloc)
            if "user_agent" in request:
                indicators["user_agents"].add(request["user_agent"])
        
        # Convert sets to lists for JSON serialization
        return {k: list(v) for k, v in indicators.items()}
    
    async def _analyze_c2_domains(self, domains: List[str]) -> List[Dict[str, Any]]:
        """Analyze domains for C2 characteristics"""
        c2_domains = []
        
        for domain in domains:
            domain_analysis = {
                "domain": domain,
                "c2_indicators": [],
                "suspicion_score": 0.0,
                "domain_age": None,
                "registrar_info": {},
                "dns_records": {},
                "reputation_score": 0.0
            }
            
            # Check for C2 domain patterns
            c2_indicators = await self._check_c2_domain_patterns(domain)
            domain_analysis["c2_indicators"] = c2_indicators
            
            # Domain age analysis
            domain_age = await self._get_domain_age(domain)
            domain_analysis["domain_age"] = domain_age
            
            # DNS record analysis
            dns_records = await self._analyze_dns_records(domain)
            domain_analysis["dns_records"] = dns_records
            
            # Calculate suspicion score
            suspicion_score = await self._calculate_domain_suspicion_score(domain_analysis)
            domain_analysis["suspicion_score"] = suspicion_score
            
            if suspicion_score > 0.3:  # Threshold for suspicious domains
                c2_domains.append(domain_analysis)
        
        return c2_domains
    
    async def _analyze_c2_ips(self, ips: List[str]) -> List[Dict[str, Any]]:
        """Analyze IP addresses for C2 characteristics"""
        c2_ips = []
        
        for ip in ips:
            try:
                ip_obj = ipaddress.ip_address(ip)
                
                ip_analysis = {
                    "ip": ip,
                    "ip_type": "public" if ip_obj.is_global else "private",
                    "geolocation": {},
                    "reputation_score": 0.0,
                    "hosting_provider": "",
                    "abuse_reports": [],
                    "c2_indicators": [],
                    "suspicion_score": 0.0
                }
                
                # Skip private IPs for C2 analysis
                if not ip_obj.is_global:
                    continue
                
                # Geolocation analysis
                geolocation = await self._get_ip_geolocation(ip)
                ip_analysis["geolocation"] = geolocation
                
                # Hosting provider analysis
                hosting_info = await self._get_hosting_provider(ip)
                ip_analysis["hosting_provider"] = hosting_info
                
                # Check for C2 IP patterns
                c2_indicators = await self._check_c2_ip_patterns(ip, ip_analysis)
                ip_analysis["c2_indicators"] = c2_indicators
                
                # Calculate suspicion score
                suspicion_score = await self._calculate_ip_suspicion_score(ip_analysis)
                ip_analysis["suspicion_score"] = suspicion_score
                
                if suspicion_score > 0.3:  # Threshold for suspicious IPs
                    c2_ips.append(ip_analysis)
                    
            except ValueError:
                logger.warning(f"Invalid IP address: {ip}")
        
        return c2_ips
    
    async def _analyze_beacon_patterns(self, network_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze network traffic for beacon patterns"""
        beacon_analysis = {
            "periodic_beacons": [],
            "jitter_analysis": {},
            "data_size_patterns": {},
            "timing_analysis": {},
            "beacon_confidence": 0.0
        }
        
        # Extract connection timestamps and sizes
        connections = network_data.get("outbound_connections", [])
        
        # Group connections by destination
        destination_groups = {}
        for conn in connections:
            dest = conn.get("destination_ip", "unknown")
            if dest not in destination_groups:
                destination_groups[dest] = []
            destination_groups[dest].append(conn)
        
        # Analyze each destination for beacon patterns
        for dest, dest_connections in destination_groups.items():
            if len(dest_connections) >= 3:  # Need minimum connections for pattern analysis
                beacon_info = await self._analyze_destination_beacon(dest, dest_connections)
                if beacon_info["is_beacon"]:
                    beacon_analysis["periodic_beacons"].append(beacon_info)
        
        # Calculate overall beacon confidence
        beacon_analysis["beacon_confidence"] = await self._calculate_beacon_confidence(beacon_analysis)
        
        return beacon_analysis
    
    async def _query_urlhaus(self, network_indicators: Dict[str, Any]) -> Dict[str, Any]:
        """Query URLhaus for malicious URL information"""
        urlhaus_results = {
            "malicious_urls": [],
            "query_timestamp": datetime.now(),
            "api_status": "unknown"
        }
        
        try:
            urls = network_indicators.get("urls", [])
            domains = network_indicators.get("domains", [])
            
            async with aiohttp.ClientSession() as session:
                # Query URLs
                for url in urls[:10]:  # Limit queries
                    result = await self._query_urlhaus_url(session, url)
                    if result and result.get("threat") != "malware_download":
                        urlhaus_results["malicious_urls"].append(result)
                
                # Query domains
                for domain in domains[:10]:  # Limit queries
                    result = await self._query_urlhaus_host(session, domain)
                    if result and result.get("threat"):
                        urlhaus_results["malicious_urls"].extend(result.get("urls", []))
            
            urlhaus_results["api_status"] = "success"
            
        except Exception as e:
            logger.error(f"URLhaus query failed: {str(e)}")
            urlhaus_results["api_status"] = "failed"
            urlhaus_results["error"] = str(e)
        
        return urlhaus_results
    
    async def _query_virustotal(self, network_indicators: Dict[str, Any]) -> Dict[str, Any]:
        """Query VirusTotal for threat intelligence"""
        vt_results = {
            "domain_reports": [],
            "ip_reports": [],
            "url_reports": [],
            "query_timestamp": datetime.now(),
            "api_status": "unknown"
        }
        
        try:
            # Note: This is a placeholder implementation
            # In production, you would need VirusTotal API key and proper rate limiting
            
            domains = network_indicators.get("domains", [])
            ips = network_indicators.get("ips", [])
            urls = network_indicators.get("urls", [])
            
            # Simulate API queries (replace with actual VirusTotal API calls)
            for domain in domains[:5]:  # Limit queries
                domain_report = {
                    "domain": domain,
                    "positives": 0,
                    "total": 0,
                    "scan_date": datetime.now().isoformat(),
                    "scans": {}
                }
                vt_results["domain_reports"].append(domain_report)
            
            vt_results["api_status"] = "simulated"
            
        except Exception as e:
            logger.error(f"VirusTotal query failed: {str(e)}")
            vt_results["api_status"] = "failed"
            vt_results["error"] = str(e)
        
        return vt_results
    
    async def _analyze_dns_patterns(self, network_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze DNS query patterns for C2 indicators"""
        dns_analysis = {
            "dga_domains": [],
            "fast_flux": [],
            "dns_tunneling": [],
            "suspicious_tlds": [],
            "query_patterns": {}
        }
        
        dns_queries = network_data.get("dns_queries", [])
        
        # Analyze for Domain Generation Algorithm (DGA) patterns
        dns_analysis["dga_domains"] = await self._detect_dga_domains(dns_queries)
        
        # Analyze for fast flux networks
        dns_analysis["fast_flux"] = await self._detect_fast_flux(dns_queries)
        
        # Analyze for DNS tunneling
        dns_analysis["dns_tunneling"] = await self._detect_dns_tunneling(dns_queries)
        
        # Analyze suspicious TLDs
        dns_analysis["suspicious_tlds"] = await self._analyze_suspicious_tlds(dns_queries)
        
        # Analyze query patterns
        dns_analysis["query_patterns"] = await self._analyze_query_patterns(dns_queries)
        
        return dns_analysis
    
    async def _analyze_traffic_patterns(self, network_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze network traffic patterns"""
        traffic_patterns = {
            "data_exfiltration": [],
            "command_injection": [],
            "payload_delivery": [],
            "heartbeat_traffic": [],
            "encrypted_channels": []
        }
        
        connections = network_data.get("outbound_connections", [])
        
        # Analyze for data exfiltration patterns
        traffic_patterns["data_exfiltration"] = await self._detect_data_exfiltration_patterns(connections)
        
        # Analyze for command injection
        traffic_patterns["command_injection"] = await self._detect_command_injection_patterns(connections)
        
        # Analyze for payload delivery
        traffic_patterns["payload_delivery"] = await self._detect_payload_delivery_patterns(connections)
        
        # Analyze for heartbeat traffic
        traffic_patterns["heartbeat_traffic"] = await self._detect_heartbeat_patterns(connections)
        
        # Analyze for encrypted channels
        traffic_patterns["encrypted_channels"] = await self._detect_encrypted_channels(connections)
        
        return traffic_patterns
    
    async def _calculate_c2_confidence(self, detection_results: Dict[str, Any]) -> float:
        """Calculate overall C2 confidence score"""
        confidence = 0.0
        
        # Domain-based indicators
        c2_domains = detection_results.get("c2_domains", [])
        if c2_domains:
            domain_score = sum(d.get("suspicion_score", 0) for d in c2_domains) / len(c2_domains)
            confidence += domain_score * 0.3
        
        # IP-based indicators
        c2_ips = detection_results.get("c2_ips", [])
        if c2_ips:
            ip_score = sum(ip.get("suspicion_score", 0) for ip in c2_ips) / len(c2_ips)
            confidence += ip_score * 0.2
        
        # Beacon analysis
        beacon_confidence = detection_results.get("beacon_analysis", {}).get("beacon_confidence", 0)
        confidence += beacon_confidence * 0.25
        
        # URLhaus results
        urlhaus_malicious = len(detection_results.get("urlhaus_results", {}).get("malicious_urls", []))
        if urlhaus_malicious > 0:
            confidence += min(urlhaus_malicious * 0.1, 0.15)
        
        # DNS analysis
        dns_indicators = detection_results.get("dns_analysis", {})
        dns_score = (len(dns_indicators.get("dga_domains", [])) + 
                    len(dns_indicators.get("dns_tunneling", []))) * 0.05
        confidence += min(dns_score, 0.1)
        
        return min(confidence, 1.0)
    
    # Helper methods
    async def _check_c2_domain_patterns(self, domain: str) -> List[str]:
        """Check domain against C2 patterns"""
        indicators = []
        
        # Check for suspicious TLDs
        suspicious_tlds = ['.tk', '.ml', '.ga', '.cf', '.top', '.click']
        if any(domain.endswith(tld) for tld in suspicious_tlds):
            indicators.append("suspicious_tld")
        
        # Check for DGA-like patterns
        if self._is_dga_domain(domain):
            indicators.append("dga_pattern")
        
        # Check for homograph attacks
        if self._has_homograph_characters(domain):
            indicators.append("homograph_attack")
        
        # Check for fast flux characteristics
        if await self._is_fast_flux_domain(domain):
            indicators.append("fast_flux")
        
        return indicators
    
    def _is_dga_domain(self, domain: str) -> bool:
        """Check if domain matches DGA patterns"""
        # Remove TLD
        domain_name = domain.split('.')[0]
        
        # Check for high entropy
        entropy = self._calculate_entropy(domain_name)
        if entropy > 4.0:
            return True
        
        # Check for random character patterns
        vowel_ratio = sum(1 for c in domain_name.lower() if c in 'aeiou') / len(domain_name)
        if vowel_ratio < 0.15 or vowel_ratio > 0.7:
            return True
        
        # Check for digit inclusion
        digit_ratio = sum(1 for c in domain_name if c.isdigit()) / len(domain_name)
        if digit_ratio > 0.3:
            return True
        
        return False
    
    def _calculate_entropy(self, string: str) -> float:
        """Calculate Shannon entropy of string"""
        if not string:
            return 0
        
        char_counts = {}
        for char in string:
            char_counts[char] = char_counts.get(char, 0) + 1
        
        entropy = 0
        string_length = len(string)
        for count in char_counts.values():
            probability = count / string_length
            entropy -= probability * (probability.bit_length() - 1)
        
        return entropy
    
    def _load_c2_patterns(self) -> Dict[str, Any]:
        """Load C2 detection patterns"""
        return {
            "beacon_intervals": [60, 300, 600, 3600],  # Common beacon intervals in seconds
            "suspicious_ports": [4444, 5555, 6666, 7777, 8080, 8443, 9999],
            "c2_user_agents": ["Mozilla/4.0", "python-requests", "curl", "wget"],
            "dga_entropy_threshold": 4.0,
            "fast_flux_ip_threshold": 10
        }
    
    def _load_beacon_patterns(self) -> Dict[str, Any]:
        """Load beacon analysis patterns"""
        return {
            "min_connections": 3,
            "jitter_threshold": 0.2,
            "periodicity_threshold": 0.8,
            "size_variance_threshold": 0.3
        }

# Factory function
def create_c2_detector() -> C2Detector:
    """Create and return C2Detector instance"""
    return C2Detector()
